---
title: 数据库
date: 2022-04-23
sidebar: auto
---

## 数据模型有哪几种？

关系模型、层次模型、网状模型

## 数据库范式？

目前关系数据库有六种范式。

1. 第一范式：实体中的某个属性不能有多个值或者不能有重复的属性，即要求属性具有原子性，不可再分解。
2. 第二范式：所有的非主属性都完全依赖于关键字，即数据库表中的每个实例都必须可以唯一的区分，即必须有主码。
3. 第三范式：每一个非主属性既不部分依赖于也不传递依赖于关键字，也就是在第二范式的基础上消除传递依赖。
4. BC 范式：在第三范式的基础上进一步消除主属性对于码的部分函数依赖和传递依赖。BC 范式需要符合第三范式，并且主属性不依赖于主属性。
5. 第四范式：如果对于 R 的每个非平凡多值依赖 X->->Y，X 都含有候选码。
6. 第五范式：在满足第四范式的基础上，表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。

具体解释可以参考[数据库设计六大范式](https://www.cnblogs.com/Diyo/p/11414424.html)。

## 连接方式？

1. left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。
2. right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。
3. inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。
4. full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。

## 数据库事务正确执行的四个要素（ACID 特性）

引入事务是为了解决并行执行的问题

1. 原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行
2. 一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。
3. 隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。
4. 持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

## 事务的并发问题

1. 脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
2. 不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。
3. 幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。

## 事务隔离级别

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| Read uncommitted（读未提交） | 是   | 是         | 是   |
| Read committed（读提交）     | 否   | 是         | 是   |
| Repeatable read （重复读）   | 否   | 否         | 是   |
| Serializable （串行化）      | 否   | 否         | 否   |

## 视图

视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。

视图的好处：

1. 视图能简化用户操作，使用户可以将注意力集中在所关心地数据上。
2. 视图对重构数据库提供了一定程度的逻辑独立性。数据的物理独立性是指用户的应用程序不依赖于数据库的物理结构。数据的逻辑独立性是指当数据库重构时，用户的应用程序不会受影响。如果定义了视图，尽管数据库的逻辑结构改变了，但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。
3. 视图能够对机密数据提供安全保护。在设计数据库时，对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。

## 索引

索引是对数据库表中一列或多列的值进行排序的一种结构。使用索引可快速访问数据库表中的特定信息。

- 索引的缺点：

  索引占用磁盘空间，并且降低添加、删除、更新行的速度。大多数情况下，索引的速度优势大大超过它的不足之处。但是如果程序非常频繁的更新数据或磁盘空间有限，则需要限制索引的数量。

- 索引类型：

  1.  唯一索引：不允许任何两行具有相同索引值的索引。
  2.  非唯一索引：允许两行具有相同索引值的索引。
  3.  主键索引：为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。
  4.  聚集索引（也叫聚簇索引）：在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。

## 为什么选择 B+树作为索引结构

- Hash 索引：Hash 索引底层是哈希表，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过 Hash 索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而 B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。
- 二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。
- AVL 树：通过旋转解决了平衡的问题，但是旋转操作效率太低。
- 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL 旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO 次数太多。
- B+树：在 B 树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。

## 锁

1. 数据库锁出现的目的：处理并发问题
2. 在 InnoDB 中实现了两个标准的行级锁，可以简单的看为两个读写锁：
   - S 共享锁：又叫读锁，其他事务可以继续加共享锁，但是不能继续加排他锁。
   - X 排他锁：又叫写锁，一旦加了写锁之后，其他事务就不能加锁了。

间隙锁：间隙锁顾名思义锁间隙，不锁记录。锁间隙的意思就是锁定某一个范围，间隙锁又叫 gap 锁，其不会阻塞其他的 gap 锁，但是会阻塞插入间隙锁，这也是用来防止幻读的关键。

## MVCC

MVCC，多版本并发控制技术。在 InnoDB 中，在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号。通过版本号和行锁，从而提高数据库系统并发性能。

在 MVCC 中，对于读操作可以分为两种读：

1. 快照读：读取的历史数据，简单的 select 语句，不加锁，MVCC 实现可重复读，使用的是 MVCC 机制读取 undo 中的已经提交的数据。所以它的读取是非阻塞的。
2. 当前读：需要加锁的语句，update，insert，delete，select...for update 等等都是当前读。

## SQL 执行顺序

SQL 的执行顺序：from---where--group by---having---select---order by
