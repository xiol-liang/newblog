(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{629:function(_,v,a){"use strict";a.r(v);var t=a(9),l=Object(t.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h2",{attrs:{id:"内核态和用户态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内核态和用户态"}},[_._v("#")]),_._v(" 内核态和用户态")]),_._v(" "),a("h3",{attrs:{id:"内核态和用户态的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内核态和用户态的区别"}},[_._v("#")]),_._v(" 内核态和用户态的区别？")]),_._v(" "),a("p",[_._v("内核态与用户态是操作系统的两种运行级别，当程序运行在 3 级特权级上时，就可以称之为运行在用户态。因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；当程序运行在 0 级特权级上时，就可以称之为运行在内核态。处于用户态执行时，进程所能访问的内存空间和对象受到限制，其占有的处理器是可被抢占的；处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。")]),_._v(" "),a("h3",{attrs:{id:"导致用户态到内核态的切换场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#导致用户态到内核态的切换场景"}},[_._v("#")]),_._v(" 导致用户态到内核态的切换场景")]),_._v(" "),a("ol",[a("li",[_._v("系统调用。这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。")]),_._v(" "),a("li",[_._v("异常。当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。")]),_._v(" "),a("li",[_._v("外围设备的中断。当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。")])]),_._v(" "),a("p",[_._v("这 3 种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。")]),_._v(" "),a("h2",{attrs:{id:"进程与线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[_._v("#")]),_._v(" 进程与线程")]),_._v(" "),a("h3",{attrs:{id:"进程和线程的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的区别"}},[_._v("#")]),_._v(" 进程和线程的区别？")]),_._v(" "),a("p",[_._v("进程和线程的主要差别在于它们是不同的操作系统资源管理方式。")]),_._v(" "),a("ol",[a("li",[_._v("进程是操作系统资源分配的最小单位，线程是 CPU 任务调度的最小单位。一个进程可以包含多个线程。")]),_._v(" "),a("li",[_._v("不同进程间数据很难共享，同一进程下不同线程间数据很易共享。")]),_._v(" "),a("li",[_._v("每个进程都有独立的代码和数据空间，进程要比线程消耗更多的计算机资源，一个进程崩溃后，在保护模式下不会对其它进程产生影响。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。")])]),_._v(" "),a("h3",{attrs:{id:"并行和并发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并行和并发"}},[_._v("#")]),_._v(" 并行和并发")]),_._v(" "),a("ol",[a("li",[_._v("并发：当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。这种方式我们称之为并发(Concurrent)。")]),_._v(" "),a("li",[_._v("并行：当系统有一个以上 CPU 时，一个 CPU 执行一个线程，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为并行(Parallel)。")])]),_._v(" "),a("h3",{attrs:{id:"进程之间的通信方式以及优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程之间的通信方式以及优缺点"}},[_._v("#")]),_._v(" 进程之间的通信方式以及优缺点")]),_._v(" "),a("ul",[a("li",[_._v("管道（PIPE）\n"),a("ul",[a("li",[_._v("有名管道：一种半双工的通信方式，可以实现任意关系的进程间的通信\n"),a("ul",[a("li",[_._v("优点：可以实现任意关系的进程间的通信")]),_._v(" "),a("li",[_._v("缺点：\n"),a("ol",[a("li",[_._v("长期存于系统中，使用不当容易出错")]),_._v(" "),a("li",[_._v("缓冲区有限")])])])])]),_._v(" "),a("li",[_._v("无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）\n"),a("ul",[a("li",[_._v("优点：简单方便")]),_._v(" "),a("li",[_._v("缺点：\n"),a("ol",[a("li",[_._v("局限于单向通信")]),_._v(" "),a("li",[_._v("只能在创建它的进程以及其有亲缘关系的进程之间通信")]),_._v(" "),a("li",[_._v("缓冲区有限")])])])])])])]),_._v(" "),a("li",[_._v("信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问\n"),a("ul",[a("li",[_._v("优点：可以同步进程")]),_._v(" "),a("li",[_._v("缺点：信号量有限")])])]),_._v(" "),a("li",[_._v("信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生")]),_._v(" "),a("li",[_._v("消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识\n"),a("ul",[a("li",[_._v("优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便")]),_._v(" "),a("li",[_._v("缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合")])])]),_._v(" "),a("li",[_._v("共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问\n"),a("ul",[a("li",[_._v("优点：无须复制，快捷，信息量大")]),_._v(" "),a("li",[_._v("缺点：\n"),a("ol",[a("li",[_._v("通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此要考虑进程间的读写操作的同步问题")]),_._v(" "),a("li",[_._v("利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信")])])])])]),_._v(" "),a("li",[_._v("套接字（Socket）：可用于不同计算机间的进程通信\n"),a("ul",[a("li",[_._v("优点：\n"),a("ol",[a("li",[_._v("传输数据为字节级，传输数据可自定义")]),_._v(" "),a("li",[_._v("传输数据时间短，性能高")]),_._v(" "),a("li",[_._v("适合于客户端和服务器端之间信息实时交互")]),_._v(" "),a("li",[_._v("可以加密,数据安全性强")])])]),_._v(" "),a("li",[_._v("缺点：需对传输的数据进行解析，转化成应用级的数据。")])])])]),_._v(" "),a("h3",{attrs:{id:"线程之间的通信方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程之间的通信方式"}},[_._v("#")]),_._v(" 线程之间的通信方式")]),_._v(" "),a("p",[_._v("线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制")]),_._v(" "),a("ul",[a("li",[_._v("锁(lock)：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）\n"),a("ul",[a("li",[_._v("互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。")]),_._v(" "),a("li",[_._v("读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。")]),_._v(" "),a("li",[_._v("自旋锁（spin lock）：互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。")]),_._v(" "),a("li",[_._v("条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。")])])]),_._v(" "),a("li",[_._v("信号量(Semaphore)")]),_._v(" "),a("li",[_._v("信号(Signal)")]),_._v(" "),a("li",[_._v("屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。")])]),_._v(" "),a("h3",{attrs:{id:"多进程与多线程的优劣对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多进程与多线程的优劣对比"}},[_._v("#")]),_._v(" 多进程与多线程的优劣对比")]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("优劣")]),_._v(" "),a("th",[_._v("多进程")]),_._v(" "),a("th",[_._v("多线程")])])]),_._v(" "),a("tbody",[a("tr",[a("td",[_._v("优点")]),_._v(" "),a("td",[_._v("编程调试简单，可靠性较高")]),_._v(" "),a("td",[_._v("速度快，资源占用小")])]),_._v(" "),a("tr",[a("td",[_._v("缺点")]),_._v(" "),a("td",[_._v("速度慢，资源占用大")]),_._v(" "),a("td",[_._v("编程、调试复杂，可靠性较差")])])])]),_._v(" "),a("h3",{attrs:{id:"互斥锁和自旋锁的应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁和自旋锁的应用场景"}},[_._v("#")]),_._v(" 互斥锁和自旋锁的应用场景？")]),_._v(" "),a("p",[_._v("线程的休眠和唤醒都是相当昂贵的操作，它们需要大量的 CPU 指令，因此需要花费一些时间，如果互斥量仅仅被锁住很短的一段时间，用来使线程休眠和唤醒线程的时间会比该线程睡眠的时间还长，甚至有可能比不断在自旋锁上轮训的时间还长，这时就应该用自旋锁。如果锁持有的时间过长，其它尝试获取自旋锁的线程会一直轮训自旋锁的状态，这将非常浪费 CPU 的执行时间，这时候使用互斥锁会是一个更好的选择。")]),_._v(" "),a("h2",{attrs:{id:"死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[_._v("#")]),_._v(" 死锁")]),_._v(" "),a("h3",{attrs:{id:"原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[_._v("#")]),_._v(" 原因？")]),_._v(" "),a("ol",[a("li",[_._v("系统资源不足")]),_._v(" "),a("li",[_._v("资源分配不当")]),_._v(" "),a("li",[_._v("进程运行推进顺序不合适")])]),_._v(" "),a("h3",{attrs:{id:"死锁的-4-个必要条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁的-4-个必要条件"}},[_._v("#")]),_._v(" 死锁的 4 个必要条件")]),_._v(" "),a("ol",[a("li",[_._v("互斥条件：一个资源每次只能被一个线程使用；")]),_._v(" "),a("li",[_._v("请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；")]),_._v(" "),a("li",[_._v("不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；")]),_._v(" "),a("li",[_._v("循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。")])]),_._v(" "),a("h3",{attrs:{id:"如何避免-预防-死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何避免-预防-死锁"}},[_._v("#")]),_._v(" 如何避免（预防）死锁")]),_._v(" "),a("ol",[a("li",[_._v("破坏"),a("code",[_._v("请求和保持")]),_._v("条件：有两种方法：\n"),a("ol",[a("li",[_._v("让进程在申请资源时，一次性申请所有需要用到的资源，不要一次一次来申请，当申请的资源有一些没空，那就让线程等待。不过这个方法比较浪费资源，进程可能经常处于饥饿状态。")]),_._v(" "),a("li",[_._v("要求进程在申请资源前，释放已经获得的资源。")])])]),_._v(" "),a("li",[_._v("破坏"),a("code",[_._v("不剥夺")]),_._v("条件：允许进程进行抢占，有两种方法：\n"),a("ol",[a("li",[_._v("如果去抢资源，被拒绝，就释放自己的资源。")]),_._v(" "),a("li",[_._v("只要优先级大，可以抢到。")])])]),_._v(" "),a("li",[_._v("破坏"),a("code",[_._v("循环等待")]),_._v("条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序提出。")])]),_._v(" "),a("h2",{attrs:{id:"虚拟存储器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟存储器"}},[_._v("#")]),_._v(" 虚拟存储器")]),_._v(" "),a("h3",{attrs:{id:"程序访问的局限性原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#程序访问的局限性原理"}},[_._v("#")]),_._v(" 程序访问的局限性原理？")]),_._v(" "),a("p",[_._v("程序访问的局部性原理：是指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。局部性原理又表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。")]),_._v(" "),a("h3",{attrs:{id:"虚拟存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟存储"}},[_._v("#")]),_._v(" 虚拟存储？")]),_._v(" "),a("p",[_._v("根据程序执行的时间局部性和空间局部性，我们允许作业装入的时候只装入一部分，另一部分放在磁盘上，当需要的时候再装入主存。用户的逻辑地址空间可以比主存的绝对地址空间要大。之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。虚拟存储器的大小由计算机的地址结构决定，并非是内存和外存的简单相加。虚拟存储器有以下三个主要特征：")]),_._v(" "),a("ol",[a("li",[_._v("多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。")]),_._v(" "),a("li",[_._v("对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。")]),_._v(" "),a("li",[_._v("虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。")])]),_._v(" "),a("p",[_._v("虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或"),a("code",[_._v("永久")]),_._v("的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：")]),_._v(" "),a("ol",[a("li",[_._v("请求分页存储管理。")]),_._v(" "),a("li",[_._v("请求分段存储管理。")]),_._v(" "),a("li",[_._v("请求段页式存储管理。")])]),_._v(" "),a("p",[_._v("不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：")]),_._v(" "),a("ol",[a("li",[_._v("一定容量的内存和外存。")]),_._v(" "),a("li",[_._v("页表机制（或段表机制），作为主要的数据结构。")]),_._v(" "),a("li",[_._v("中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。")]),_._v(" "),a("li",[_._v("地址变换机构，逻辑地址到物理地址的变换。")])]),_._v(" "),a("h3",{attrs:{id:"页面置换算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页面置换算法"}},[_._v("#")]),_._v(" 页面置换算法")]),_._v(" "),a("p",[_._v("在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。")]),_._v(" "),a("h3",{attrs:{id:"cache-工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cache-工作原理"}},[_._v("#")]),_._v(" cache 工作原理？")]),_._v(" "),a("p",[_._v("cache，高速缓冲存储器，是一种容量小而速度快的高度缓冲器，以 RAM 为材料制成。引入的原因主要有：")]),_._v(" "),a("ol",[a("li",[_._v("I/O 设备向主存的访问级别高于 CPU，在 I/O 访存期间，CPU 将处于空闲状态。")]),_._v(" "),a("li",[_._v("主存速度的提高始终跟不上 CPU 的发展，主存与 CPU 的速度明显不匹配。")])]),_._v(" "),a("p",[_._v("Cache 直接做在 CPU 内，速度几乎与 CPU 一样快，任何时刻都有一些主存块处于缓存之中，因此，CPU 欲访问主存的时候，有两种可能：")]),_._v(" "),a("ol",[a("li",[_._v("所需要的字已经在缓存中，于是 CPU 直接访问 Cache，简称 Cache 命中。")]),_._v(" "),a("li",[_._v("所需要的字不在缓存中，那么此时需要将字所在的主存块整块一次调入 Cache 中，（即主存-Cache 之间以块为单位进行传送 ）。")])]),_._v(" "),a("p",[_._v("通常用命中率来衡量 Cache 的效率 。 在一个程序执行期间，设总的命中次数为 Nc，访问主存的次数为 Nm，那么命中率为：$H=N_c/(N_c+N_m)$")]),_._v(" "),a("p",[_._v("在 Cache 中，地址映射是指把主存地址空间映射到 Cache 地址空间，在将主存块复制到 Cache 中的时候遵循一定的映射规则，标志位为 1 时候，表示其 Cache 映射的主存块数据有效。 地址映射有三种方式：直接映射，全相联映射，组相联映射。")]),_._v(" "),a("ol",[a("li",[a("p",[_._v("直接映射")]),_._v(" "),a("p",[_._v("这种方式主存块只能装入 Cache 的唯一位置，若该位置已有内容，则产生块冲突，原来在 Cache 中的块将无条件被替换出去，直接映射的关系可以定义为：$j=i\\ mod\\ 2^c$，其中，j 为 Cache 的块号或者行号。i 为主存块号，$2^c$为 Cache 的总块数。这种方式映射不够灵活。地址结构为：")]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("主存字块标记")]),_._v(" "),a("th",[_._v("Cache 字块标记")]),_._v(" "),a("th",[_._v("字块内地址")])])]),_._v(" "),a("tbody")]),_._v(" "),a("p",[_._v("CPU 的访存过程：首先根据地址中间的 Cache 字块地址，直接找到对应的 Cache 块号，若块号的有效位为 1，则表示命；，否则为不命中，此时从主存中读取该地址所在的主存块号，并将其内容送到对应的 Cache 块并将有效位置 1，同时将内容送到 CPU。")])]),_._v(" "),a("li",[a("p",[_._v("全相联映射")]),_._v(" "),a("p",[_._v("这种方式可以把主存数据块装入 Cache 的任意一块，方式可以从已占满的 Cache 存储块中，替换出任一旧块，显然这种方式灵活，命中率也高，与直接相联映射相比，其主存字块位数增加，使得 Cache 标记位增多地址变换速度慢。通常使用“按内容寻址的”相联存储器。其地址结构为：")]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("主存字块标记")]),_._v(" "),a("th",[_._v("字块内地址")])])]),_._v(" "),a("tbody")])]),_._v(" "),a("li",[a("p",[_._v("组相联映射")]),_._v(" "),a("p",[_._v("将 Cache 空间分成大小相同的组，主存的一个数据块可以装到组内的任一个位置，即组间采取直接映射，组内采取全相联映射。如果把 Cache 分成 Q 组，每组有 R 块，那么有： $i= j\\ mod\\ q$，其中 i 为缓存的组号，j 为主存块号主存地址分为三个字段：")]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("主存字块标记")]),_._v(" "),a("th",[_._v("组地址")]),_._v(" "),a("th",[_._v("字块内地址")])])]),_._v(" "),a("tbody")]),_._v(" "),a("p",[_._v("当组内有 k 块的时候，称为 k 路组相联映射。\nCPU 访存过程：首先根据中间的组地址，找到对应的 Cache 组，若其标记位为 1，说明命中，此时根据块内地址，在对应得 Cache 行中，存取信息；若不命中，那么此时从主存中读出该地址所在的主存号块，送到对应的 Cache 组的任一行，有效位置 1，同时将内容送到 CPU 中。")])])])])}),[],!1,null,null,null);v.default=l.exports}}]);