(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{625:function(v,_,t){"use strict";t.r(_);var l=t(9),i=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"分治算法、动态规划、回溯法、分支定界法、贪心算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分治算法、动态规划、回溯法、分支定界法、贪心算法"}},[v._v("#")]),v._v(" 分治算法、动态规划、回溯法、分支定界法、贪心算法")]),v._v(" "),t("ol",[t("li",[v._v("分治算法：将一个大问题，分割成一些规模较小的子问题，这些子问题相互独立且与原问题性质相同，求出子问题的解，就可得到原问题的解。")]),v._v(" "),t("li",[v._v("动态规划：将一个大问题，分割成一些规模较小的子问题，求出子问题的解，就可得到原问题的解。与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的。为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在数组中。")]),v._v(" "),t("li",[v._v("回溯法：在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果不包含，则逐层向其祖先结点回溯。")]),v._v(" "),t("li",[v._v("分支限界法：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。分支限界法常以广度优先或以最小耗费优先的方式搜索问题的解空间树。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。")]),v._v(" "),t("li",[v._v("贪心算法：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。贪心策略适用的前提是：局部最优策略能导致产生全局最优解。")])]),v._v(" "),t("h2",{attrs:{id:"快速排序的思想、优化方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速排序的思想、优化方法"}},[v._v("#")]),v._v(" 快速排序的思想、优化方法")]),v._v(" "),t("ol",[t("li",[v._v("快速排序的基本思想：快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。")]),v._v(" "),t("li",[v._v("快速排序的三个步骤：\n"),t("ol",[t("li",[v._v('选择枢纽元：在待排序列中，按照某种方式挑出一个元素，作为 "枢纽元"（pivot）')]),v._v(" "),t("li",[v._v("分割操作：以该枢纽元在序列中的实际位置，把序列分成两个子序列。此时，在枢纽元左边的元素都比该枢纽元小，在枢纽元右边的元素都比枢纽元大")]),v._v(" "),t("li",[v._v("递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。")])])]),v._v(" "),t("li",[v._v("优化方法\n"),t("ol",[t("li",[v._v("当待排序序列的长度分割到比较小的长度后，使用插入排序。")]),v._v(" "),t("li",[v._v("在每一次分割结束后，可以把与划分元相等的元素聚在一起，继续下次分割时，不用再对与划分元相等元素分割。")]),v._v(" "),t("li",[v._v("最佳划分是将序列划分成等长的两个子序列，因此提出三数取中的思想。取序列中，下标第一位，下标中间一位，下标最后一位的三个数进行排序，取排序结果中排中间的数据作为划分元。")]),v._v(" "),t("li",[v._v("快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。")])])])])])}),[],!1,null,null,null);_.default=i.exports}}]);