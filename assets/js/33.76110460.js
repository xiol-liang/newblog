(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{628:function(_,t,v){"use strict";v.r(t);var a=v(9),e=Object(a.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("本文所说的"),v("code",[_._v("现代C++")]),_._v("是指 C++11 以后的 C++版本，本文主要总结针对 C++11 以后的 C++新特性的常见面试问题，有关传统 C++的面试问题请参考"),v("RouterLink",{attrs:{to:"/docs/CS_basic/C++.html"}},[_._v("C++.md")]),_._v("文件。")],1),_._v(" "),v("h2",{attrs:{id:"c-11-的新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#c-11-的新特性"}},[_._v("#")]),_._v(" C++11 的新特性？")]),_._v(" "),v("ol",[v("li",[_._v("核心特性："),v("strong",[_._v("智能指针、右值引用、移动语义、完美转发、lambda 表达式")]),_._v("（必答）")]),_._v(" "),v("li",[_._v("其它特性：auto、decltype、long long、函数返回类型自动推导、删除函数、列表初始化、nullptr、using 声明、限定作用域的枚举类型、const_iterator、override 声明、noexcept 声明、constexpr、范围 for 循环")])]),_._v(" "),v("h2",{attrs:{id:"左值和右值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#左值和右值"}},[_._v("#")]),_._v(" 左值和右值")]),_._v(" "),v("p",[_._v("看能不能对表达式取地址，如果能则为左值，否则为右值")]),_._v(" "),v("h2",{attrs:{id:"移动语义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#移动语义"}},[_._v("#")]),_._v(" 移动语义")]),_._v(" "),v("p",[_._v("移动语义是指某个对象接管另一个对象所拥有的外部资源的所有权。移动语义的具体实现（即一次 that 对象到 this 对象的移动（move））通常包含以下若干步骤：")]),_._v(" "),v("ol",[v("li",[_._v("如果 this 对象自身也拥有资源，释放该资源")]),_._v(" "),v("li",[_._v("将 this 对象的指针或句柄指向 that 对象所拥有的资源")]),_._v(" "),v("li",[_._v("将 that 对象原本指向该资源的指针或句柄设为空值")])]),_._v(" "),v("h2",{attrs:{id:"unordered-map-和-map-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#unordered-map-和-map-区别"}},[_._v("#")]),_._v(" unordered_map 和 map 区别？")]),_._v(" "),v("ol",[v("li",[_._v("map 内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而 AVL 是严格平衡二叉搜索树），因此 map 内部的所有元素都是有序的，存取一个元素时间复杂度是 O(logn)")]),_._v(" "),v("li",[_._v("unordered_map 内部实现了一个哈希表，其元素的排列顺序是无序的，取一个元素时间复杂度是 O(1)")])]),_._v(" "),v("h2",{attrs:{id:"c-容器类的底层实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#c-容器类的底层实现"}},[_._v("#")]),_._v(" C++容器类的底层实现？")]),_._v(" "),v("p",[v("strong",[_._v("以下分别用"),v("code",[_._v("K")]),_._v("、"),v("code",[_._v("T")]),_._v("指代泛型参数")]),_._v("。")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("C++")]),_._v(" "),v("th",[_._v("特点")]),_._v(" "),v("th",[_._v("底层数据结构")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("T 变量名[数值]")]),_._v("、"),v("code",[_._v("array<T,数值>")])]),_._v(" "),v("td",[_._v("固定大小数组。支持快速随机访问，不能添加和删除元素")]),_._v(" "),v("td",[_._v("普通数组")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("vector<T>")])]),_._v(" "),v("td",[_._v("可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢")]),_._v(" "),v("td",[_._v("数组")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("list<T>")])]),_._v(" "),v("td",[_._v("双向循环链表。只支持双向顺序访问，在任何位置进行插入删除操作都很快")]),_._v(" "),v("td",[_._v("链表")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("forward_list<T>")])]),_._v(" "),v("td",[_._v("单向链表。只支持单向顺序访问，在任何位置进行插入删除操作都很快")]),_._v(" "),v("td",[_._v("链表")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("stack<T>")])]),_._v(" "),v("td",[_._v("栈。后进先出容器")]),_._v(" "),v("td",[_._v("数组或链表")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("queue<T>")])]),_._v(" "),v("td",[_._v("队列。先进先出容器")]),_._v(" "),v("td",[_._v("数组或链表")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("deque<T>")])]),_._v(" "),v("td",[_._v("双端队列。支持首尾快速增删，也支持随机访问")]),_._v(" "),v("td",[_._v("底层数据结构为一个中央控制器和多个缓冲区")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("priority_queue<T>")])]),_._v(" "),v("td",[_._v("优先级队列。队列中的元素具有优先级，优先级最高的元素位于队首，队首元素可以弹出队列")]),_._v(" "),v("td",[_._v("二叉大根堆")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("unordered_set<T>")])]),_._v(" "),v("td",[_._v("集合。关键字无序且不可重复出现")]),_._v(" "),v("td",[_._v("哈希表")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("set<T>")])]),_._v(" "),v("td",[_._v("集合。关键字有序且不可重复出现")]),_._v(" "),v("td",[_._v("红黑树")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("unordered_map<K,T>")])]),_._v(" "),v("td",[_._v("关联数组。保存键值对，键值对无序且键不可重复出现")]),_._v(" "),v("td",[_._v("哈希表")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("map<K,T>")])]),_._v(" "),v("td",[_._v("关联数组。保存键值对，键值对有序且键不可重复出现")]),_._v(" "),v("td",[_._v("红黑树")])])])]),_._v(" "),v("p",[_._v("注意 stack、queue、priority_queue 均为容器适配器。stack 和 queue 底层一般用 list 或 deque 实现，不用 vector 的原因应该是容量大小有限制，扩容耗时。priority_queue 一般用 vector 作底层容器。")]),_._v(" "),v("h2",{attrs:{id:"智能指针"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#智能指针"}},[_._v("#")]),_._v(" 智能指针？")]),_._v(" "),v("p",[_._v("C++11 中引入了智能指针的概念，方便管理堆内存。智能指针是利用了一种叫做 RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。智能指针就是一个作用是资源管理的类，它是在堆栈上声明的类模板，并可通过使用指向某个堆分配的对象的裸指针进行初始化（RAII）。在初始化智能指针后，它将拥有裸指针，这意味着智能指针负责删除裸指针指定的内存， 智能指针析构函数包括要删除的调用，当智能指针超出范围时将调用其析构函数，析构函数会自动释放资源。")]),_._v(" "),v("ol",[v("li",[_._v("unique_ptr：实现的是专属所有权的语义，它是智能指针的默认选项。unique_ptr 是个只移型别，不能复制或共享。unique_ptr 小巧高效，大小等同于一个指针且支持右值引用，从而可实现快速插入和对 STL 集合的检索。")]),_._v(" "),v("li",[_._v("shared_ptr：采用引用计数的智能指针。如果你想要将一个裸指针分配给多个所有者，请使用该指针。直至所有 shared_ptr 所有者超出了范围或放弃所有权，才会删除裸指针。大小为两个裸指针：一个用于指向裸指针指向的对象，另一个用于指向包含引用计数的共享控制块。")]),_._v(" "),v("li",[_._v("weak_ptr ：结合 shared_ptr 使用的特例智能指针。 weak_ptr 提供对一个或多个 shared_ptr 实例拥有的对象的访问，但不参与引用计数。如果你想要观察某个对象但不需要其保持活动状态，请使用该实例。在某些情况下，用于断开 shared_ptr 实例间的循环引用。")])]),_._v(" "),v("h2",{attrs:{id:"shared-ptr-的线程安全性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#shared-ptr-的线程安全性"}},[_._v("#")]),_._v(" shared_ptr 的线程安全性？")]),_._v(" "),v("p",[_._v("两个角度：")]),_._v(" "),v("ol",[v("li",[_._v("引用计数的操作必须是原子的！（标准库中已经实现了引用计数的原子性）")]),_._v(" "),v("li",[_._v("多线程读写 shared_ptr 要加锁！（查看"),v("a",{attrs:{href:"https://blog.csdn.net/Solstice/article/details/8547547",target:"_blank",rel:"noopener noreferrer"}},[_._v("讲解链接"),v("OutboundLink")],1),_._v("）")])]),_._v(" "),v("h2",{attrs:{id:"lambda-表达式的捕获列表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lambda-表达式的捕获列表"}},[_._v("#")]),_._v(" lambda 表达式的捕获列表？")]),_._v(" "),v("ol",[v("li",[v("code",[_._v("[]")]),_._v("：空捕获列表。lambda 不能使用所在函数中的任何局部变量；")]),_._v(" "),v("li",[v("code",[_._v("[a, b, ……]")]),_._v("：以值捕获方式捕获局部变量 a, b, ……；")]),_._v(" "),v("li",[v("code",[_._v("[&a, &b, ……]")]),_._v("：以引用捕获方式捕获局部变量 a, b, ……；")]),_._v(" "),v("li",[v("code",[_._v("[=]")]),_._v("：以值捕获方式捕获 lambda 表达式所在的函数体内所有局部变量；")]),_._v(" "),v("li",[v("code",[_._v("[&]")]),_._v("：以引用捕获方式捕获 lambda 表达式所在的函数体内所有局部变量；")]),_._v(" "),v("li",[v("code",[_._v("[&, a, b, ……]")]),_._v("：以值捕获方式捕获局部变量 a, b, ……，除此以外 lambda 表达式所在的函数体内所有局部变量都以引用捕获方式捕获；")]),_._v(" "),v("li",[v("code",[_._v("[=, &a, &b, ……]")]),_._v("：以引用捕获方式捕获局部变量 a, b, ……，除此以外 lambda 表达式所在的函数体内所有局部变量都以值捕获方式捕获。")])]),_._v(" "),v("p",[_._v("注意，lambda 表达式无需捕获即可直接使用全局变量以及全局函数。")]),_._v(" "),v("h2",{attrs:{id:"auto-和-decltype-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#auto-和-decltype-的区别"}},[_._v("#")]),_._v(" auto 和 decltype 的区别")]),_._v(" "),v("p",[_._v("auto 会忽略引用和顶层 const，但底层 const 会被保留下来；但 decltype 不会忽略。")]),_._v(" "),v("h2",{attrs:{id:"c-20-四大新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#c-20-四大新特性"}},[_._v("#")]),_._v(" C++20 四大新特性")]),_._v(" "),v("ol",[v("li",[_._v("Concepts（概念）：简化泛型编程，一个 Concept 就是一个编译期判断，用于约束模版参数，Concepts 则是这些编译期判断的合集。")]),_._v(" "),v("li",[_._v("Ranges（范围）：一个引用元素序列的对象，在概念上类似于一对迭代器。可以很方便地将多个算法组合在一起，写法更简单，语义更清晰，并且还可以实现延迟计算避免了中间的临时变量，性能也会更好。")]),_._v(" "),v("li",[_._v("Modules（模块）：取代头文件，通过 import 包来使用库。")]),_._v(" "),v("li",[_._v("Coroutines（协程）：简化异步网络程序的编写，co_await 用来挂起和恢复一个协程，co_return 用来返回协程的结果，co_yield 返回一个值并且挂起协程。如果一个函数体中有这三个关键字之一就变成 Coroutine 了。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);